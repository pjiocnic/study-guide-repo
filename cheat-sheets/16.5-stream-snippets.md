
# Examples of anyMatch, allMatch and noneMatch

1. How to only copy elements from list2 that aren't already in list1?

```java
import java.util.List;
import java.util.stream.Collectors;

public class ListCopyExample {

    public static <T> void copyIfNotPresent(List<T> list1, List<T> list2) {
        List<T> elementsToAdd = list2.stream()
                .filter(element -> !list1.contains(element))  // Find elements not in list1
                .collect(Collectors.toList());

        list1.addAll(elementsToAdd);  // Add them to list1
    }

    // alternatively use noneMatch
    public static <T> void copyIfNotPresent2(List<T> list1, List<T> list2) {
        List<T> elementsToAdd = list2.stream()
                .filter(element -> list1.stream().noneMatch(e -> e.equals(element))) // Use anyMatch to find non-matching elements
                .collect(Collectors.toList());

        list1.addAll(elementsToAdd);  // Add them to list1
    }

    public static void main(String[] args) {
        List<String> list1 = List.of("apple", "banana", "orange");
        List<String> list2 = List.of("banana", "grape", "pear");

        // Convert to mutable list (as List.of() returns immutable lists)
        list1 = list1.stream().collect(Collectors.toList());

        copyIfNotPresent(list1, list2);

        System.out.println(list1);
    }
}

```

# References

1. [Short-Circuiting Operations in Java Stream API: Demystifying anyMatch, allMatch, and noneMatch](https://medium.com/@satyendra.jaiswal/short-circuiting-operations-in-java-stream-api-demystifying-anymatch-allmatch-and-nonematch-df9f2e475d3a)

# In prep

A good one-to-many use case in Java can be modeled in a variety of real-world scenarios where one entity relates to multiple other entities. A classic example is a **Course-Student relationship** in a university system. Here, a course can be taken by many students, and each student can enroll in many courses (this is actually a many-to-many relationship, but we'll simplify it to one-to-many for now by considering a course as the primary focus).

### Example: One-to-Many Use Case (Course - Student)

In this use case:
- One **Course** can be taken by many **Students**.
- The **Course** is the "one" side, and **Student** is the "many" side.

### Java Code:

```java
import java.util.ArrayList;
import java.util.List;

public class Course {
    private String courseName;
    private List<Student> students;  // One course can have many students

    public Course(String courseName) {
        this.courseName = courseName;
        this.students = new ArrayList<>();
    }

    // Add a student to the course
    public void addStudent(Student student) {
        students.add(student);
    }

    // Get the list of students enrolled in the course
    public List<Student> getStudents() {
        return students;
    }

    @Override
    public String toString() {
        return "Course: " + courseName;
    }
}

class Student {
    private String studentName;

    public Student(String studentName) {
        this.studentName = studentName;
    }

    @Override
    public String toString() {
        return "Student: " + studentName;
    }
}

public class Main {
    public static void main(String[] args) {
        // Create course
        Course course = new Course("Introduction to Java");

        // Create students
        Student student1 = new Student("Alice");
        Student student2 = new Student("Bob");

        // Add students to the course
        course.addStudent(student1);
        course.addStudent(student2);

        // Print course details and list of students
        System.out.println(course);
        for (Student student : course.getStudents()) {
            System.out.println(student);
        }
    }
}
```

### Explanation:

1. **Course**: The `Course` class represents the "one" side. It has a list of `Student` objects (the "many" side) representing the students enrolled in the course.
2. **Student**: The `Student` class is simple, with just a name to identify each student.
3. **Main**: In the `Main` class, we create a course and some students, add the students to the course, and print out the course along with the enrolled students.

### Output:

```
Course: Introduction to Java
Student: Alice
Student: Bob
```

This is a typical one-to-many relationship where a course can have multiple students. Itâ€™s a good use case for understanding relationships in object-oriented programming, and such patterns are often used in enterprise applications, such as employee-management systems, school management systems, and customer-product systems.