<h1>powertools-for-python</h1>

1. AWS Serverless Application Model (SAM) example

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: Powertools for AWS Lambda (Python) version

Globals:
  Function:
    Timeout: 5
    Runtime: python3.11
    Tracing: Active  # must have permissions to send traces to AWS X-Ray
    Environment:
      Variables:
        POWERTOOLS_SERVICE_NAME: payment
    Layers:
      # Find the latest Layer version in the official documentation
      # https://docs.powertools.aws.dev/lambda/python/latest/#lambda-layer
      - !Sub arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:48

Resources:
  CaptureLambdaHandlerExample:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: ../src
      Handler: capture_lambda_handler.handler

```

2. Lambda handler

```javascript {.line-numbers}
from aws_lambda_powertools import Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext

tracer = Tracer()  # Sets service via POWERTOOLS_SERVICE_NAME env var
# OR tracer = Tracer(service="example")


def collect_payment(charge_id: str) -> str:
    return f"dummy payment collected for charge: {charge_id}"

@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> str:
    charge_id = event.get("charge_id", "")
    return collect_payment(charge_id=charge_id)

```

Note: @tracer.capture_lambda_handler decorator creates following additional decorators

* Creates a `ColdStart annotation` to easily filter traces that have had an initialization overhead
* Creates a `Service annotation` if service parameter or POWERTOOLS_SERVICE_NAME is set
* Captures any response, or full exceptions generated by the handler, and include as tracing metadata

3. Adding **custom Annotations**

```javascript {.line-numbers}
from aws_lambda_powertools import Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext

tracer = Tracer()


def collect_payment(charge_id: str) -> str:
    tracer.put_annotation(key="PaymentId", value=charge_id) # custom Annotations: key-values associated with **traces** and **indexed** by AWS X-Ray
    return f"dummy payment collected for charge: {charge_id}"


@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> str:
    charge_id = event.get("charge_id", "")
    return collect_payment(charge_id=charge_id)

```

4. Adding **custom Metadata**

```javascript {.line-numbers}
from aws_lambda_powertools import Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext

tracer = Tracer()


def collect_payment(charge_id: str) -> str:
    return f"dummy payment collected for charge: {charge_id}"


@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> str:
    payment_context = {
        "charge_id": event.get("charge_id", ""),
        "merchant_id": event.get("merchant_id", ""),
        "request_id": context.aws_request_id,
    }
    payment_context["receipt_id"] = collect_payment(charge_id=payment_context["charge_id"])
    tracer.put_metadata(key="payment_response", value=payment_context) # custom metadata

    return payment_context["receipt_id"]

```

5. Difference between **Metadata** and **Annotations**

* **Annotations** are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions.

* **Metadata** are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object.

6. Use decorator `tracer.capture_method` to trace an **arbitrary** function


```py
from aws_lambda_powertools import Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext

tracer = Tracer()


@tracer.capture_method
def collect_payment(charge_id: str) -> str:
    tracer.put_annotation(key="PaymentId", value=charge_id)
    return f"dummy payment collected for charge: {charge_id}"


@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> str:
    charge_id = event.get("charge_id", "")
    return collect_payment(charge_id=charge_id)

```

# 1. [TODO] Asynchronous and generator functions

1. AWS does not support **asynchronous Lambda handler**
1. [TODO] What do these functions do? capture_method_async.py, capture_method_context_manager.py, capture_method_generators.py

## 1.1. What are generator functions?

# 2. Environment Variables to configure Tracing

* **POWERTOOLS_TRACE_DISABLED**
* **POWERTOOLS_TRACER_CAPTURE_RESPONSE**: Captures Lambda or method return as metadata.
* **POWERTOOLS_TRACER_CAPTURE_ERROR**: Captures Lambda or method exception as metadata.

Note: Both **POWERTOOLS_TRACER_CAPTURE_RESPONSE** and **POWERTOOLS_TRACER_CAPTURE_ERROR** can be set on a per-method basis, consequently overriding the environment variable value.

# 3. [TODO] Patching Modules

```py
import requests

from aws_lambda_powertools import Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext

MODULES = ["requests"]

tracer = Tracer(patch_modules=MODULES)  # [TODO] How does this work?


@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> str:
    ret = requests.get("https://httpbin.org/get")
    ret.raise_for_status()

    return ret.json()

```

# 4. How to disable response auto-capture


```py
from aws_lambda_powertools import Logger, Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext

tracer = Tracer()
logger = Logger()


@tracer.capture_method(capture_response=False)
def collect_payment(charge_id: str) -> str:
    tracer.put_annotation(key="PaymentId", value=charge_id)
    logger.debug("Returning sensitive information....")
    return f"dummy payment collected for charge: {charge_id}"


@tracer.capture_lambda_handler(capture_response=False)
def lambda_handler(event: dict, context: LambdaContext) -> str:
    charge_id = event.get("charge_id", "")
    return collect_payment(charge_id=charge_id)

```

## 4.1. When would you want to disable response auto-capture?

1. You might return sensitive information you don't want it to be added to your traces
2. You might manipulate streaming objects that can be read only once; this prevents subsequent calls from being empty
3. You might return more than 64K of data e.g., message too long error